<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>labitbu.com üëπ</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      background: #fff;
      line-height: 1.4;
      text-align: center;
    }
    #labitbu-container {
      max-width: 720px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    button {
      background: #007bff;
      color: #fff;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      transition: background-color 0.2s, opacity 0.2s;
    }
    button:hover:not(:disabled) {
      background: #0056b3;
    }
    button:disabled {
      background: #6c757d;
      cursor: default;
      opacity: 0.6;
    }
    #beta-banner {
      background: #fff3cd;
      color: #856404;
      padding: 0.75rem 1rem;
      font-size: 0.85rem;
    }
    input {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 100%;
      max-width: 300px;
      box-sizing: border-box;
      margin-top: 0.5rem;
    }
    code {
      font-size: 0.8rem;
      background: #eee;
      padding: 3px 5px;
      border-radius: 4px;
      word-wrap: break-word;
    }
    ul { text-align: left; display: inline-block; font-size: 0.8rem; padding-left: 1.2rem; }
    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 1rem auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="beta-banner"> ‚ö†Ô∏è This is a <strong>beta</strong> product &mdash; free mint, no official
    collection yet, only a handful of basic traits.  
    There's currently no labitbu explorer and no inscription wallet that supports this control-block protocol.</div>
  <div id="labitbu-container">
    <h1 style="text-align:center;color:#333;">labitbu.com üëπ</h1>

    <div style="text-align:center;margin-bottom:2rem;">
      <a class="github-button" href="https://github.com/stutxo/labitbu"
         data-show-count="true" aria-label="Star stutxo/labitbu on GitHub">Star</a>
    </div>

    <p style="text-align:center;color:#333;font-size:0.9rem;">An unknown amount of labitbu's have escaped and are running free in the merkle forest, can you find them all? Some say they hide in a mysterious place called control block 128</p>

    <div style="text-align: center;">
      <div style="color:#333;font-size:0.7rem;margin:0 auto 1rem auto; display: inline-block; text-align: left;">
        <p style="font-size:0.9rem;margin:0 0 0.5rem 0;"><strong>Rules:</strong></p>
        <ul style="margin:0;padding-left:1.2rem;">
          <li>A labitbu's control block must have a depth of 128</li>
          <li>The internal key used must be the labitbu NUMS collection key<br>
            <code>96053db5b18967b5a410326ecca687441579225a6d190f398e2180deec6e429e</code>
          </li>
          <li>We will use ordinals theory to track the labitbu's</li>
          <li>This is a proof of concept, be careful out there!</li>
          <li>This is all running locally with xverse and mempool api, you always control your funds</li>
        </ul>
      </div>
    </div>

    <div style="margin: 2rem 0">
      <button id="connect-btn">1. Connect Xverse</button>
      <p id="connect-error" style="color:red;"></p>
    </div>

    <div id="type-selection-section" style="display:none;">
        <p><strong>Choose your labitbu type:</strong></p>
        <button id="mint-sleepy">Mint Sleepy üò¥</button>
        <button id="mint-legacy">Mint OG üòé</button>
    </div>

    <div id="display-labitbu" style="margin-top:2rem;"></div>

    <div id="deposit-section" style="display:none; margin-top:1rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px;">
        <p>A Labitbu has been generated. Click below to fund its address.</p>
        <p>Deposit Address: <code id="deposit-address"></code></p>
        <button id="initiate-deposit-btn">2. Deposit 10,000 sats</button>
        <div id="deposit-status" style="margin-top:1rem;"></div>
    </div>
    
    <div id="destination-section" style="display:none; margin-top:1rem;">
      <p><strong>‚úÖ Deposit Received!</strong></p>
      <p>Enter your Ordinals-safe destination address (starts with bc1p).</p>
      <input id="destination-address" placeholder="bc1p‚Ä¶" />
      <br/>
      <button id="mint-btn" disabled>3. Mint Now</button>
      <p id="mint-status" style="color:red;"></p>
    </div>

  </div>

  <script async defer src="https://buttons.github.io/buttons.js"></script>

  <script type="module">
    document.addEventListener('DOMContentLoaded', async () => {
      const { request, AddressPurpose } = await import('https://esm.sh/sats-connect');
      const { default: initWasm, create_deposit_address, mint, generate_labitbu_bytes } = await import('./pkg/labitbu.js');
      const { default: mempoolJS } = await import('https://esm.sh/@mempool/mempool.js');
      const { Buffer } = await import('https://esm.sh/buffer');

      await initWasm();
      const mempool = mempoolJS({ hostname: 'mempool.space' }).bitcoin;
      const $ = id => document.getElementById(id);
      const sleep = ms => new Promise(r => setTimeout(r, ms));

      function hexToBytes(hex) {
        const out = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
          out[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
        return out;
      }

      const { labitbus, accessories } = await (await fetch('/labitbu-traits.json')).json();
      const legacyBase = Object.values(labitbus).map(hexToBytes);
      const legacyAcc = Object.values(accessories).map(hexToBytes);

      const { Lasnoozesnooze, traits } = await (await fetch('/lasnoozesnooze.json')).json();
      const sleepyBase = Object.values(Lasnoozesnooze).map(hexToBytes);
      const sleepyAcc = Object.values(traits).map(hexToBytes);

      const traitData = {
        sleepy: { base: sleepyBase, acc: sleepyAcc },
        legacy: { base: legacyBase, acc: legacyAcc }
      };

      const state = {
        paymentPublicKey: null,
        paymentAddress: null,
        depositAddress: null,
        imageBytes: null,
        utxos: null,
        destinationAddress: null,
      };

      function renderImage(bytes) {
        const url = URL.createObjectURL(new Blob([bytes], { type: 'image/webp' }));
        const img = new Image();
        img.src = url;
        img.style.maxWidth = '100%';
        $('display-labitbu').replaceChildren(img);
      }

      function updateStatus(elementId, message, color = 'black') {
        const el = $(elementId);
        el.innerHTML = message;
        el.style.color = color;
      }

      $('connect-btn').onclick = async () => {
        try {
          const response = await request('wallet_connect', null);
          if (response.status !== 'success') throw new Error('Wallet connection failed.');
          const paymentAddressInfo = response.result.addresses.find(a => a.purpose === AddressPurpose.Payment);
          if (!paymentAddressInfo) throw new Error('No Taproot payment address found in wallet.');
          
          state.paymentPublicKey = paymentAddressInfo.publicKey.slice(2);
          state.paymentAddress = paymentAddressInfo.address;

          $('connect-btn').disabled = true;
          $('type-selection-section').style.display = 'block';
        } catch (err) {
          updateStatus('connect-error', err.message, 'red');
        }
      };

      async function selectMintType(traitKey) {
        $('mint-sleepy').disabled = true;
        $('mint-legacy').disabled = true;

        const selectedTraits = traitData[traitKey];
        state.imageBytes = generate_labitbu_bytes(state.paymentPublicKey, selectedTraits.base, selectedTraits.acc);
        state.depositAddress = new TextDecoder().decode(create_deposit_address(state.paymentPublicKey, state.imageBytes));
        
        renderImage(state.imageBytes);
        $('deposit-address').textContent = state.depositAddress;
        $('deposit-section').style.display = 'block';
        updateStatus('deposit-status', 'Checking for existing deposit... <div class="loader"></div>', 'blue');

        try {
            const existingUtxos = await mempool.addresses.getAddressTxsUtxo({ address: state.depositAddress });
            if (existingUtxos.length > 0) {
                state.utxos = existingUtxos;
                updateStatus('deposit-status', '‚úÖ Existing deposit found!', 'green');
                setTimeout(() => {
                    $('deposit-section').style.display = 'none';
                    $('destination-section').style.display = 'block';
                }, 1000);
            } else {
                updateStatus('deposit-status', '');
                $('initiate-deposit-btn').style.display = 'inline-block';
            }
        } catch (e) {
            console.error("Mempool check failed:", e);
            updateStatus('deposit-status', 'Could not check for existing deposits. Please proceed manually.', 'red');
            $('initiate-deposit-btn').style.display = 'inline-block';
        }
      }
      $('mint-sleepy').onclick = () => selectMintType('sleepy');
      $('mint-legacy').onclick = () => selectMintType('legacy');

      $('initiate-deposit-btn').onclick = async () => {
        $('initiate-deposit-btn').disabled = true;
        
        try {
          updateStatus('deposit-status', 'Please approve the transaction in your wallet...', 'blue');
          const tx = await request('sendTransfer', {
            recipients: [{ address: state.depositAddress, amount: 10000, memo: 'Labitbu mint deposit' }]
          });
          if (tx.status !== 'success') {
            throw new Error(tx.error?.message || 'Transaction was not approved.');
          }
          
          updateStatus('deposit-status', 'Waiting for transaction to confirm... <div class="loader"></div>', 'blue');
          
          while (true) {
            const utxos = await mempool.addresses.getAddressTxsUtxo({ address: state.depositAddress });
            if (utxos.length > 0) {
              state.utxos = utxos;
              $('deposit-section').style.display = 'none';
              $('destination-section').style.display = 'block';
              break;
            }
            await sleep(2000);
          }
        } catch (e) {
          console.error("Deposit/Polling Error:", e);
          updateStatus('deposit-status', e.message, 'red');
          $('initiate-deposit-btn').disabled = false;
        }
      };

      $('destination-address').oninput = (e) => {
        const addr = e.target.value.trim();
        $('mint-btn').disabled = true;
        updateStatus('mint-status', '', 'red');

        if (!addr.startsWith('bc1p')) {
          updateStatus('mint-status', 'Address must be Taproot (start with bc1p).'); return;
        }
        if (addr.length !== 62) {
          updateStatus('mint-status', 'Address must be 62 characters long.'); return;
        }
        
        updateStatus('mint-status', '');
        state.destinationAddress = addr;
        $('mint-btn').disabled = false;
      };

      $('mint-btn').onclick = async () => {
        $('mint-btn').disabled = true;
        try {
          updateStatus('mint-status', 'Building transaction...', 'blue');
          const prevOuts = await Promise.all(state.utxos.map(async ({ txid, vout }) => {
            const tx = await mempool.transactions.getTx({ txid });
            return { value: Number(tx.vout[vout].value), script_pubkey: tx.vout[vout].scriptpubkey };
          }));
          const totalIn = state.utxos.reduce((sum, u) => sum + BigInt(u.value), 0n);
          const feeRate = (await mempool.fees.getFeesRecommended()).fastestFee;
          const fee = BigInt(Math.ceil(feeRate)) * 1200n;

          if (totalIn <= fee) throw new Error(`Deposit is not enough to cover the network fee.`);
          if (totalIn - fee < 330n) throw new Error('Output amount is too low (dust).');

          const inputs = state.utxos.map(u => ({ previous_output: `${u.txid}:${u.vout}`, sequence: 0xFFFFFFFD, script_sig: '', witness: [] }));
          const psbtBytes = mint(state.paymentPublicKey, state.imageBytes, totalIn, state.destinationAddress, fee, inputs, prevOuts);
          const psbtBase64 = Buffer.from(psbtBytes).toString('base64');
          
          updateStatus('mint-status', 'Please sign in your wallet...', 'blue');
          const signResponse = await request('signPsbt', {
            psbt: psbtBase64,
            signInputs: { [state.paymentAddress]: state.utxos.map((_, i) => i) },
            broadcast: true
          });
          
          if (signResponse.status !== 'success') throw new Error(signResponse.error?.message || 'Signing or broadcast failed.');
          
          const txLink = `https://mempool.space/tx/${signResponse.result.txid}`;
          updateStatus('mint-status', `<strong>Success!</strong> <a href="${txLink}" target="_blank">View Transaction</a>`, 'green');

        } catch (err) {
          updateStatus('mint-status', err.message, 'red');
          $('mint-btn').disabled = false;
        }
      };
    });
  </script>
</body>
</html>